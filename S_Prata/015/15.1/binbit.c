/* binbit.c -- using bit operations to display binary */
#include <stdio.h>
#include <limits.h>  // for CHAR_BIT, # of bits per char
char * itobs(int, char *);
void show_bstr(const char *);

int main(void)
{
    // CHAR_BIT из заголовочного файла limits.h. //  макрос представляет количество битов в типе char
    char bin_str[CHAR_BIT * sizeof(int) + 1]; // sizeof(int) = 4 (байта ) // CHAR_BIT = 8 бит
    // т.е. bin_str{33} // Массив bin_str содержит на один элемент больше чем 32, чтобы можно было добавить в него завершающий нулевой символ.
    int number;

    puts("Enter integers and see them in binary.");
    puts("Non-numeric input terminates program.");
    while (scanf("%d", &number) == 1)
    {
        itobs(number,bin_str);
        printf("%d is ", number);
        show_bstr(bin_str);
        putchar('\n');
    }
    puts("Bye!");

    return 0;
}

char * itobs(int n, char * ps) // например ввели ===25=== это 11001 
{
    int i;
    const static int size = CHAR_BIT * sizeof(int); // size=32 (8х4=32)

	// формируем массив из нулей и едениц - эквивалент введенного десятичного значения
	//
	// ========  пишем в массив значения побитово ============
	//
	// например ввели ===25=== это 00000000 00000000 00000000 00011001 
    for (i = size - 1; i >= 0; i--, n >>= 1) // уже в цикле сдвигаем вправо 00011001 на еденицу(т.е. на один бит), получаем 0.. ... ... 00001100 
		// начинаем присваиваить 1 или 0 с большего индекса массива к меньшему индексу, 
        ps[i] = (01 & n) + '0'; // Операнд 01 — это восмеричное представление маски, у которой все биты кроме нулевого установлены в 0 (можно применить шестнадцатиричное представление маски - 0х1). // === результатом 01 & n будет значение последнего бита в n. Значением является 0 или 1, но для массива необходим символ '0' или символ '1. Преобразование в символ осуществляется добавлением кода для '0'
		// код символа 0 это 00110000 //  в цикле идет сложение 0 или 1 с нулем, таким образом мы получаем символ нуля или еденицы
		/*
========как происходит преобразование int в char=========
согласно таблице ASCII 
символ '0' (нуля) это 0011 0000 (1 байт)
1 это число ( 4 байта) 00000000 00000000 00000000 00000001 , младший байт от 1 это 00000001
0 это число ( 4 байта)
сумма 1 + '0' это 00000001 + 00110000 = 0011 0001  (символ еденицы)
сумма 2 + '0' это 00000010 + 00110000 = 0110 0010  (символ двойки)
		*/

    ps[size] = '\0'; // ps[32]='\0' - это тридцать третий элемент

    return ps;
}

/* show binary string in blocks of 4 */
void show_bstr(const char * str)
{ // функция show_bstr (), которая разбивает последовательность битов на группы по четыре, чтобы облегчить восприятие строки.
    int i = 0;

    while (str[i])  /* not the null character */
    {
        putchar(str[i]); //  превоначально i=0
        if(++i % 4 == 0 && str[i]) // через каждые четыре символа
            putchar(' '); // вставка пробела
    }
}
/*
>Enter integers and see them in binary.
Non-numeric input terminates program.
>10
10 is 0000 0000 0000 0000 0000 0000 0000 1010
*/
